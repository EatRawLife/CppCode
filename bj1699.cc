//실버 2
//제곱 수의 합

//제곱수를 구하는것을 dp거로 (이미 구한 걸 이용 한다고 하면.)
//자신보다 작은 값에다가 제곱수를 더해서 자신이 나올 것. 
//자신의 앞의 수 + 자신보다 작은 제곱수를 더했을때의 최소의 값. 
//근데 이문제를 왜 dp로 구해야한다고 생각해야할까? 이 생각의 흐름이 좀 궁금함. 

//초기항 > dp[0] = 없음. (자연수), dp[1] = 1
//점화식 > min(인덱스에 제곱수를 더해서 자신이 될 수 있는 자신보다 작은 항) + 1
//필요한 것 > 자기 앞의 모든 항. 

#include <iostream> 
#include <vector>

std::vector<int> dp;
int N;

int main() {
    std::cin >> N;
    dp.push_back(0);//빼서 0되는 경우 편하게 계산 해 주기위함임.
    dp.push_back(1);

    for(int i = 2; i <= N; i++) {
        int min = i;
        for(int j = 1; j*j <= i; j++) { // 틀렸었음. 처음에 등호 반대, dp.at의 값을 쓰기도함. 배열이 뭐를 뜻하는지 제대로 생각하지 않아 생긴 문제. 이런 실수 너무 많이 한다. 내가 지금 쓰려는게 정확히 무슨 뜻인지 확실히 알고 풀자.
            if(min >= (dp.at(i- j*j) + 1)){
                min = dp.at(i- j*j) + 1;
            }
        }
        dp.push_back(min);
    }

    std::cout << dp[N];
}
