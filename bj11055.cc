//수열A에서 증가하는 부분 수열중 합이 가장 큰 것구하기
//가장 간단한 방법은 맨 마지막 원소 값이 가장 큰 값이 오게 하는 것.
//하지만 이는 문제가 있다. 현재 수열이 이전값을 모르는 것.
//따라서 현재 원소는 현재 증가하는 수열의 값을 적는 것.
//식: if a이전항 < a지금항 => s 지금항 =s이전항 + a지금항  else s 지금항 = a. 지금항
//답 : 배열 중에서 가장 큰 것.
//잠깐 부분 수열이다. 중간에 끊겨도 모른다.
//뭘 기억해야할까. 일단 현재 항에서 다음 항은 뒤에 나보다 큰항이면 무엇이든 될 수 있다.
//그렇다면 그 이전항의 후보중 가장 수열의 길이가 큰 값에 대하여서 가져와서 +1 하면된다.
//우리가 구할 수열의 현재항 값 = 해당 항을 포함하는 수열중 가장 긴 길이와 그 합 (보조 리스트를 이용).
//구할 항 값 = max(mat(더작은)항) +1
//prerequisite = 이전의 모든항(작은 것부터 큰 곳으로.)
//시작 값 = 0
//답 = 쭉 뒤져야
//시간 복잡도 > n * 각 위치마다 이전 모든게 후보 n + n 찾기 = n제곱(문제 없음)
//이런 값을 잘못 읽었다. 길이가 가장 긴 것이아니라 크기가 가장 커야한다. 이런;;

//잠깐 부분 수열이다. 중간에 끊겨도 모른다.
//뭘 기억해야할까. 일단 현재 항에서 다음 항은 뒤에 나보다 큰항이면 무엇이든 될 수 있다.
//현재 항에 저장할 것은, 해당위치까지의 가장 큰 수열 항들의 합.
//그렇다면 그 이전항의 후보중 가장 수열의 합이 큰 값에 대하여서 가져와서 +이항 값 하면된다.
//우리가 구할 수열의 현재항 값 = 해당 항을 포함하는 수열중 가장 긴 길이와 그 합 (보조 리스트를 이용).
//구할 항 값 = max(이전 sum) +mat(지금)
//prerequisite = 이전의 모든항(작은 것부터 큰 곳으로.)
//시작 값 = 0
//답 = 쭉 뒤져
//아뭐야 트레이스 필요 없다. 문제좀 읽자.
#include <iostream>
#include <vector>

int N;
std::vector<int> arr; //실제 배열
std::vector<int> sum; //구할 배열


int main() {
  std::cin >> N;
  for(int i = 0; i< N; i++) {
    int a;
    std::cin >> a;
    arr.push_back(a);
  }
  
  sum.push_back(arr.at(0));//초기 조건 세팅

  for(int i = 1; i< N; i++) {
    int valuesum = arr[i];
    int valueofarri = arr[i];
    for(int j = 0; j<i; j++) {
      if(arr[i] > arr[j] && valuesum < sum[j] + valueofarri){
        valuesum = sum[j] + valueofarri;
      }
    }
    sum.push_back(valuesum);
  }

  int max = 0;
  for(int i = 0; i< N; i++) {
    if(sum[i] > max){
      max = sum[i];
    }
  }

  std::cout << max;
}

//풀이시간 약 40분,
//평가 > 문제좀 똑바로보자.