//단 하나의 주식만 계속 따라갈거임
//형태를 함수처럼 해서 여러 케이스에 대해 돌아가도록 할거임
//하루에 하나씩 주식을 살수 있고, 팔때는 다팔수 있음. 다시 생각해보니 당연한 소리. 미래를 알아서 확실한 수익성이 보장된다면 다팔아버려야지... 그날에 사긴또 왜삼
//지금 당정 떨어진다해도 고점이 있다면 그때 파는 것이 이득이지. 그전에 떨어지는건 의미가 없지.
//따라서 뒤에 고점이 있다면 무조건 그때가서 팔아야 이득이다. 그러나 처음부터 시작하면 고점을 알 수 없다.
//뒤에서 부터 맥스를 저장하면서온다.
//만약 현재값이 맥스 미만이라면 그때가서 팔아 제낄 것이므로 구매. 맥스 - 현재값 만큼 이득
//만약 현재값이 맥스와 같다면 살이유가 없다. +- 제로일 것. 이날은 아무것도 하지 않겠지 > 이득 x
//만약 현재값이 맥스보다 크다면 신 고점이다. 이날은 이전것 팔아 버리겠지. > 이득 x, 단 이전일 수는 이날 기준으로 사야하므로 max 갱신. 

//처음 풀어보는 실버쪽 그리디 문제. 상당히 생각도 못한 풀이 방법 이었다. (뒤에서 부터 오기 같은 거라던가..)
//이번에는 하루에 하나만 할 수 있어, 이득이 없어서 아무것도 안하는 날과 판매하는 일이 겹칠 수 있었지만, 만약 하루에 할수 있는게 정해져 있거나하면 상당히 복잡한 문제가 될 수 도 있다는 생각이 들었다.
//뭐 이건 지금 케이스를 고민해 보는 것보다는 레벨 높은 그리디 문제를 풀다보면 알게 되겠지.

#include <iostream>
#include <vector>
#include <sstream>
int N;
std::ostringstream str;

void invest() {
  int M;
  std::vector<int> v;

  std::cin >> M;

  for(int i = 0; i<M; i++){
    int temp;
    std::cin >> temp;
    v.push_back(temp);
  }

  int max = 0;
  
  long long earning = 0;
  //미리 수익을 계산.

  for(int i = M-1; i>=0; i--) {
    int now = v.at(i);

    if(now < max) {
      earning += (max-now);
    } else {
      max = now;
    }
   

  }

  str << earning <<'\n';

}

int main(){
  std::cin >> N;

  for(int i = 0; i< N; i++) {
    invest();
  }

  std::cout << str.str() << std::flush;
}
